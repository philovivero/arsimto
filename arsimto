#!/usr/bin/perl
# vim: set noexpandtab:
# --
# A recent battle with vim and a Go program finally settled this for me.
# Tabs for indent, spaces for formatting. If you change your shiftwidth and
# tabstop to different values and your code looks ugly, say aloud: tabs
# for indent, spaces for formatting.
# --
# arsimto is a radically-simple inventory management tool.
# license: gpl v2.
# author: Tim Ellis, CTO Fifth Sigma, Inc.

use strict;
use warnings;

# things passed in via arguments
my $mode = '';
my $verbose = 0;
my $assetList = '';
my $attrList = '';
my @extraArgs;

# names of directories
my $poolDir = "./Pools";
my $assetDir = "./Assets";

foreach my $arg (@ARGV) {
	if ($arg =~ /^-+h(elp)*$/)          { doArgs(); exit 0; }
	elsif ($arg =~ /^-+assets=(.+)$/)   { $assetList = $1; }
	elsif ($arg =~ /^-+attrs=(.+)$/)    { $attrList = $1; }
	elsif ($arg =~ /^-+v(erbose)*$/)     { $verbose = 1; }
	elsif ($arg =~ /^add$|^connect$|^list$|^report$/)   { $mode = $arg; }
	else { push (@extraArgs, $arg); }
}

# if they don't know what they're doing, help them
unless ($mode) { doArgs() ; exit 0; }
if ($verbose) { print "mode=$mode ; assetList=$assetList ; attrList=$attrList ; extraArgs=@extraArgs\n"; }

# determine the mode they're requesting and do the needful
if ($mode eq 'add') {
	addAssets();
} elsif ($mode eq 'connect') {
	connectAssets();
} elsif ($mode eq 'list') {
	listAssets();
} elsif ($mode eq 'report') {
	reportAssets();
}

sub doArgs {
	print "usage: $0 [-v] [-h] <command>\n";
   	print "  --assets=<assetList>\n";
	print "  [--attrs=<attrList>]\n";
	print "\n";
	print "  -h       (This) help\n";
	print "  -v       Verbose/debugging output\n";
	print "\n";
	print "Command 'add':\n";
	print "  $0 add --assets=<assetName>[,<assetName>...] --attrs=n1:v1[,n2:v2,...,nN:vN]\n";
	print "Examples:\n";
	print "  $0 add --assets=switch01 --attrs=ports:48\n";
	print "  $0 add --assets=server01,server02,server03 --attrs=ram:16GB,disk:2048GB,nic:10Gb\n";
	print "  $0 add --assets=server01 --attrs=ip:192.168.1.101\n";
	print "  $0 add --assets=server02 --attrs=ip:192.168.1.102\n";
	print "  $0 add --assets=server03 --attrs=ip:192.168.1.103\n";
	print "\n";
	print "Command 'connect':\n";
	print "  $0 connect --assets=<parentAsset>,<childAsset>[,<childAsset>...]\n";
	print "Examples:\n";
	print "  $0 connect --assets=switch01,server01,server02,server03\n";
	print "  $0 connect --assets=www,server01\n";
	print "  $0 connect --assets=db,server02,server03\n";
	print "\n";
	print "Command 'list':\n";
	print "  $0 list <object> --attrs=n1[,n2...]\n";
	print "Examples:\n";
	print "  $0 list Assets\n";
	print "  $0 list Pools/poolName\n";
	print "  $0 list Pools/poolName --attrs=name,ip\n";
	print "\n";
	print "Command 'report':\n";
	print "  $0 report <object> --attrs=n1[,n2...]\n";
	print "Examples:\n";
	print "  $0 report Pools/db --attrs=ram,ip\n";
	print "  $0 report Pools/www --attrs=ip,nic\n";
	print "\n";
}

# add assets to the database
sub addAssets {
	foreach my $asset (split(/,/, $assetList)) {
		if ($verbose) { print STDERR " + Adding asset $asset\n"; }
		system ("mkdir -p $assetDir/$asset");
		foreach my $attr (split(/,/, $attrList)) {
			system ("touch $assetDir/$asset/$attr");
		}
	}
}

# simply connect assets to each other
sub connectAssets {
	if ($assetList =~ /^(.+?),(.+)$/) {
		my $parentAsset = $1;
		my $childAssets = $2;

		foreach my $childAsset (split(/,/, $childAssets)) {
			if ($verbose) { print STDERR " + Connecting $parentAsset --> $childAsset\n"; }
			system ("mkdir -p $poolDir/$parentAsset && cd $poolDir/$parentAsset && ln -sf ../../$assetDir/$childAsset ./");
		}
	} else {
		print STDERR " E Error: You must provide a list of assets to connect.\n";
	}
}

# simple list of what assets are in what - also applies to pools
sub listAssets {
	foreach my $listDest (@extraArgs) {
		if ($verbose) { print STDERR " - Traversing $listDest\n"; }
		system ("ls -1 $listDest");
	}
}

# collect the attrs for every asset specified then dump it out
sub reportAssets {
	my $objectList = '';
	my $reportHash;

	# first collect all attributes of all assets in the pools specified
	foreach my $reportDest (@extraArgs) {
		$objectList .= `find -L $reportDest -type f -name '*:*'`;
	}

	# next, grab out the attributes we want and put into a hash of assets
	foreach my $oneLine (split(/\n/, $objectList)) {
		if ($oneLine =~ /^.+\/(.+?)\/(.+?):(.+)$/) {
			my $assetName = $1;
			my $attrName = $2;
			my $attrVal = $3;

			# if this attribute matches the list they want, put into report
			if ($attrList =~ /\b$attrName\b/) {
				$reportHash->{$assetName}->{$attrName} = $attrVal;
			}
		}
	}

	# output the report
	foreach my $assetName (sort keys %{$reportHash}) {
		print "$assetName";
		foreach my $attrName (split(/,/, $attrList)) {
			print "\t" . $reportHash->{$assetName}->{$attrName};
		}
		print "\n";
	}
}

