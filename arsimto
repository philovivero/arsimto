#!/usr/bin/perl
# vim: set noexpandtab:
# --
# A recent battle with vim and a Go program finally settled this for me.
# Tabs for indent, spaces for formatting. If you change your shiftwidth and
# tabstop to different values and your code looks ugly, say aloud: tabs
# for indent, spaces for formatting.
# --
# arsimto is a radically-simple inventory management tool.
# license: gpl v2.
# author: Tim Ellis, CTO Fifth Sigma, Inc.

use strict;
use warnings;

# things passed in via arguments
my $mode = '';
my $verbose = 0;
my $assetList = '';
my $attrList = '';
my @extraArgs;

# names of directories
my $poolDir = "Pools";
my $assetDir = "Assets";

# a constant meaning an entry is at the top of a tree
my $topLevel = '__TOP_LEVEL_NO_PARENT';

foreach my $arg (@ARGV) {
	if ($arg =~ /^-+h(elp)*$/)          { doArgs(); exit 0; }
	elsif ($arg =~ /^-+assets=(.+)$/)   { $assetList = $1; }
	elsif ($arg =~ /^-+attrs=(.+)$/)    { $attrList = $1; }
	elsif ($arg =~ /^-+v(erbose)*$/)     { $verbose = 1; }
	elsif ($arg =~ /^add$|^connect$|^list$|^report$/)   { $mode = $arg; }
	else { push (@extraArgs, $arg); }
}

# if they don't know what they're doing, help them
unless ($mode) { doArgs() ; exit 0; }
if ($verbose) { print "mode=$mode ; assetList=$assetList ; attrList=$attrList ; extraArgs=@extraArgs\n"; }

# determine the mode they're requesting and do the needful
if ($mode eq 'add') {
	addAssets();
} elsif ($mode eq 'connect') {
	connectAssets();
} elsif ($mode eq 'list') {
	listAssets();
} elsif ($mode eq 'report') {
	reportAssets();
}

sub doArgs {
	print "usage: $0 [-v] [-h] <command>\n";
   	print "  --assets=<assetList>\n";
	print "  [--attrs=<attrList>]\n";
	print "\n";
	print "  -h       (This) help\n";
	print "  -v       Verbose/debugging output\n";
	print "\n";
	print "Command 'add':\n";
	print "  $0 add --assets=<assetName>[,<assetName>...] --attrs=n1:v1[,n2:v2,...,nN:vN]\n";
	print "Examples:\n";
	print "  $0 add --assets=switch01 --attrs=ports:48\n";
	print "  $0 add --assets=server01,server02,server03 --attrs=ram:16GB,disk:2048GB,nic:10Gb\n";
	print "  $0 add --assets=server01 --attrs=ip:192.168.1.101\n";
	print "  $0 add --assets=server02 --attrs=ip:192.168.1.102\n";
	print "  $0 add --assets=server03 --attrs=ip:192.168.1.103\n";
	print "\n";
	print "Command 'connect':\n";
	print "  $0 connect --assets=<parentAsset>,<childAsset>[,<childAsset>...]\n";
	print "Examples:\n";
	print "  $0 connect --assets=switch01,server01,server02,server03\n";
	print "  $0 connect --assets=www,server01\n";
	print "  $0 connect --assets=db,server02,server03\n";
	print "\n";
	print "Command 'list':\n";
	print "  $0 list <object> --attrs=n1[,n2...]\n";
	print "Examples:\n";
	print "  $0 list Assets\n";
	print "  $0 list Pools/poolName\n";
	print "  $0 list Pools/poolName --attrs=name,ip\n";
	print "\n";
	print "Command 'report':\n";
	print "  $0 report <object> --attrs=n1[,n2...]\n";
	print "Examples:\n";
	print "  $0 report Pools/db --attrs=ram,ip\n";
	print "  $0 report Pools/www --attrs=ip,nic\n";
	print "\n";
}

# add assets to the database
sub addAssets {
	foreach my $asset (split(/,/, $assetList)) {
		if ($verbose) { print STDERR " + Adding asset $asset\n"; }
		system ("mkdir -p $assetDir/$asset");
		foreach my $attr (split(/,/, $attrList)) {
			system ("touch $assetDir/$asset/$attr");
		}
	}
}

# simply connect assets to each other
sub connectAssets {
	if ($assetList =~ /^(.+?),(.+)$/) {
		my $parentAsset = $1;
		my $childAssets = $2;

		foreach my $childAsset (split(/,/, $childAssets)) {
			if ($verbose) { print STDERR " + Connecting $parentAsset --> $childAsset\n"; }
			system ("mkdir -p $poolDir/$parentAsset && cd $poolDir/$parentAsset && ln -sf ../../$assetDir/$childAsset ./");
		}
	} else {
		print STDERR " E Error: You must provide a list of assets to connect.\n";
	}
}

# simple list of what assets are in what - also applies to pools
# if a given Pools/X contains an asset Y, and Pools/Y exists,
# then Pools/Y is a child of Pools/X
sub listAssets {
	my $reportHash;
	my $poolHash;

	# First, build a hash of pools:
	#   reportHash->{datacenter01} = top
	#   reportHash->{switch01} = top
	#   reportHash->{db} = top
	#
	# Next, get assets in each:
	#   datacenter01 children = switch01
	#   switch01 children = server01..server03
	#   db children = server01
	#
	# Next, iterate through assets of a pool. if poolHash->{pool.childN}
	# exists, then pool.childN is a pool, thus:
	#   reportHash->{pool}->{children} = child01
	#   reportHash->{child01} = pool

	foreach my $listDest (@extraArgs) {
		if ($verbose) { print STDERR " - Traversing $listDest\n"; }

		# we're checking if they're checking top-level pools or some
		# deeply-nested object. deeply-nested ones we won't worry about
		# hierarchies
		if ($listDest =~ /^$poolDir\/*$/) {
			# first collect all top-level pool names, some of which might
			# be children of others
			my @poolList = split(/\n/, `ls -1 $listDest`);

			# put the list of top-level pools into the report hash...
			foreach my $currPool (@poolList) {
				$reportHash->{$currPool}->{'parent'} = $topLevel;
			}

			# second collect all assets inside the top-level pool names
			# and if they match top-level pool, create two-way link between
			# them in the hash
			foreach my $currPool (@poolList) {
				my @assetList = split(/\n/, `ls -1 $listDest/$currPool`);

				foreach my $oneAsset (@assetList) {
					if (defined $reportHash->{$oneAsset}) {
						if ($verbose) { print STDERR "   - setting $currPool --> $oneAsset parent/child\n"; }
						$reportHash->{$oneAsset}->{'parent'} = $currPool;
						$reportHash->{$currPool}->{'children'} .= "$oneAsset,";
					}
				}
			}

			# third, output the hash
			outputHashTree ($reportHash, $topLevel, 0);
		} else {
			system ("ls -1 $listDest");
		}
	}

}

# traverse a tree struct implemented inside a hash
sub outputHashTree {
	my $hashToTraverse = shift;
	my $rootLevel = shift;
	my $indent = shift;

	my $leadSpaces = '';
	for (my $i=0; $i < $indent; $i++) {
		$leadSpaces .= "  ";
	}
	$indent++;

	foreach my $parentKey (sort keys %{$hashToTraverse}) {
		if ($hashToTraverse->{$parentKey}->{'parent'} eq $rootLevel) {
			print "$leadSpaces$parentKey\n";
			if (defined $hashToTraverse->{$parentKey}->{'children'}) {
				outputHashTree ($hashToTraverse, $parentKey, $indent);
			}
		}
	}
}

# collect the attrs for every asset specified then dump it out
sub reportAssets {
	my $objectList = '';
	my $reportHash;

	# first collect all attributes of all assets in the pools specified
	foreach my $reportDest (@extraArgs) {
		$objectList .= `find -L $reportDest -type f -name '*:*'`;
	}

	# next, grab out the attributes we want and put into a hash of assets
	foreach my $oneLine (split(/\n/, $objectList)) {
		if ($oneLine =~ /^.+\/(.+?)\/(.+?):(.+)$/) {
			my $assetName = $1;
			my $attrName = $2;
			my $attrVal = $3;

			# if this attribute matches the list they want, put into report
			if ($attrList =~ /\b$attrName\b/) {
				$reportHash->{$assetName}->{$attrName} = $attrVal;
			}
		}
	}

	# output the report
	foreach my $assetName (sort keys %{$reportHash}) {
		print "$assetName";
		foreach my $attrName (split(/,/, $attrList)) {
			print "\t" . $reportHash->{$assetName}->{$attrName};
		}
		print "\n";
	}
}

