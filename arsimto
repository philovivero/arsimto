#!/usr/bin/perl
# vim: set noexpandtab:
# --
# A recent battle with vim and a Go program finally settled this for me.
# Tabs for indent, spaces for formatting. If you change your shiftwidth and
# tabstop to different values and your code looks ugly, say aloud: tabs
# for indent, spaces for formatting.
# --
# arsimto is a radically-simple inventory management tool.
# license: gpl v2.
# author: Tim Ellis, CTO Fifth Sigma, Inc.

use strict;
use warnings;

# things passed in via arguments
my $mode = '';
my $verbose = 0;
my $assetList = '';
my $dataList = '';
my @extraArgs;

# names of directories
my $poolDir = "Pools";
my $assetDir = "Assets";

# a constant meaning an entry is at the top of a tree
my $topLevel = '__TOP_LEVEL_NO_PARENT';

foreach my $arg (@ARGV) {
	if ($arg =~ /^-+h(elp)*$/)                  { doArgs(); exit 0; }
	elsif ($arg =~ /^-+a(ssets)*=(.+)$/)        { $assetList = $2; }
	elsif ($arg =~ /^-+d(ata)*=(.+)$/)          { $dataList = $2; }
	elsif ($arg =~ /^-+v(erbose)*$/)            { $verbose = 1; }
	elsif ($arg =~ /^add$|^connect$|^list$|^report$/)   { $mode = $arg; }
	else { push (@extraArgs, $arg); }
}

# if they don't know what they're doing, help them
unless ($mode) { doArgs() ; exit 0; }
if ($verbose) { print "mode=$mode ; assetList=$assetList ; dataList=$dataList ; extraArgs=@extraArgs\n"; }

# determine the mode they're requesting and do the needful
if ($mode eq 'add') {
	addAssets();
} elsif ($mode eq 'connect') {
	connectAssets();
} elsif ($mode eq 'list') {
	listAssets();
} elsif ($mode eq 'report') {
	reportAssets();
}

sub doArgs {
	print "usage: $0 [-v] [-h] <command>\n";
   	print "  --assets=<assetList>\n";
	print "  [--data=<dataList>]\n";
	print "\n";
	print "  -h       (This) help\n";
	print "  -v       Verbose/debugging output\n";
	print "\n";
	print "Command 'add':\n";
	print "  $0 add --assets=<assetName>[,<assetName>...] --data=n1:v1[,n2:v2,...,nN:vN]\n";
	print "Examples:\n";
	print "  $0 add --assets=dc01   --data=capacity:5000\n";
	print "  $0 add --assets=rack01   --data=U:48\n";
	print "  $0 add --assets=switch01 --data=ports:48\n";
	print "  $0 add --assets=server01,server02,server03 --data=ram:16GB,disk:2048GB,nic:10Gb\n";
	print "  $0 add --assets=server01 --data=ip:192.168.1.101\n";
	print "  $0 add --assets=server02 --data=ip:192.168.1.102\n";
	print "  $0 add --assets=server03 --data=ip:192.168.1.103\n";
	print "\n";
	print "Command 'connect':\n";
	print "  $0 connect --assets=<parentAsset>,<childAsset>[,<childAsset>...]\n";
	print "Examples:\n";
	print "  $0 connect --assets=dc01,rack01\n";
	print "  $0 connect --assets=rack01,switch01\n";
	print "  $0 connect --assets=switch01,server01,server02,server03\n";
	print "  $0 connect --assets=www,server01\n";
	print "  $0 connect --assets=db,server02,server03\n";
	print "\n";
	print "Command 'list':\n";
	print "  $0 list <object>\n";
	print "Examples:\n";
	print "  $0 list Assets\n";
	print "  $0 list Pools/poolName\n";
	print "\n";
	print "Command 'report':\n";
	print "  $0 report <object> --data=n1[,n2...]\n";
	print "Examples:\n";
	print "  $0 report --data=ram,ip Pools/db\n";
	print "  $0 report --data=ip,nic Pools/www\n";
	print "\n";
}

# add assets to the database
sub addAssets {
	foreach my $asset (split(/,/, $assetList)) {
		if ($verbose) { print STDERR " + Adding asset $asset\n"; }
		system ("mkdir -p $assetDir/$asset");
		foreach my $data (split(/,/, $dataList)) {
			system ("touch $assetDir/$asset/$data");
		}
	}
}

# simply connect assets to each other
sub connectAssets {
	if ($assetList =~ /^(.+?),(.+)$/) {
		my $parentAsset = $1;
		my $childAssets = $2;

		foreach my $childAsset (split(/,/, $childAssets)) {
			if ($verbose) { print STDERR " + Connecting $parentAsset --> $childAsset\n"; }
			system ("mkdir -p $poolDir/$parentAsset && cd $poolDir/$parentAsset && if [ -d ../../$assetDir/$childAsset ] ; then ln -sf ../../$assetDir/$childAsset ./ ; fi ; if [ -d ../$childAsset ] ; then ln -sf ../$childAsset ./ ; fi");
		}
	} else {
		print STDERR " E Error: You must provide a list of assets to connect.\n";
	}
}

# simple list of what assets are in what - also applies to pools
# if a given Pools/X contains an asset Y, and Pools/Y exists,
# then Pools/Y is a child of Pools/X
sub listAssets {
	my $reportHash;
	my $poolHash;

	# First, build a hash of pools:
	#   reportHash->{datacenter01} = top
	#   reportHash->{switch01} = top
	#   reportHash->{db} = top
	#
	# Next, get assets in each:
	#   datacenter01 children = switch01
	#   switch01 children = server01..server03
	#   db children = server01
	#
	# Next, iterate through assets of a pool. if poolHash->{pool.childN}
	# exists, then pool.childN is a pool, thus:
	#   reportHash->{pool}->{children} = child01
	#   reportHash->{child01} = pool

	foreach my $listDest (@extraArgs) {
		if ($verbose) { print STDERR " - Traversing $listDest\n"; }

		# we're checking if they're checking top-level pools or some
		# deeply-nested object. deeply-nested ones we won't worry about
		# hierarchies
		if ($listDest =~ /^$poolDir\/*$/) {
			# first collect all top-level pool names, some of which might
			# be children of others
			my @poolList = split(/\n/, `ls -1 $listDest`);

			# put the list of top-level pools into the report hash...
			foreach my $currPool (@poolList) {
				$reportHash->{$currPool}->{'parent'} = $topLevel;
			}

			# second collect all assets inside the top-level pool names
			# and if they match top-level pool, create two-way link between
			# them in the hash
			foreach my $currPool (@poolList) {
				my @assetList = split(/\n/, `ls -1 $listDest/$currPool`);

				foreach my $oneAsset (@assetList) {
					if (defined $reportHash->{$oneAsset}) {
						if ($verbose) { print STDERR "   - setting $currPool --> $oneAsset parent/child\n"; }
						$reportHash->{$oneAsset}->{'parent'} = $currPool;
						$reportHash->{$currPool}->{'children'} .= "$oneAsset,";
					}
				}
			}

			# third, output the hash
			outputHashTree ($reportHash, $topLevel, 0);
		} else {
			system ("ls -1 $listDest");
		}
	}
}

# traverse a tree struct implemented inside a hash
sub outputHashTree {
	my $hashToTraverse = shift;
	my $rootLevel = shift;
	my $indent = shift;

	my $leadSpaces = '';
	for (my $i=0; $i < $indent; $i++) {
		$leadSpaces .= "  ";
	}
	$indent++;

	foreach my $parentKey (sort keys %{$hashToTraverse}) {
		if ($hashToTraverse->{$parentKey}->{'parent'} eq $rootLevel) {
			print "$leadSpaces$parentKey\n";
			if (defined $hashToTraverse->{$parentKey}->{'children'}) {
				outputHashTree ($hashToTraverse, $parentKey, $indent);
			}
		}
	}
}

# collect the data for every asset specified then dump it out
sub reportAssets {
	my $objectList = '';
	my $reportHash;

	# first collect all data of all assets in the pools specified
	foreach my $reportDest (@extraArgs) {
		$objectList .= `find -L $reportDest -type f -name '*:*'`;
	}

	# next, grab out the data we want and put into a hash of assets
	foreach my $oneLine (split(/\n/, $objectList)) {
		if ($oneLine =~ /^.+\/(.+?)\/(.+?):(.+)$/) {
			my $assetName = $1;
			my $dataName = $2;
			my $dataVal = $3;

			# if this data matches the list they want, put into report
			if ($dataList =~ /\b$dataName\b/) {
				$reportHash->{$assetName}->{$dataName} = $dataVal;
			}
		}
	}

	# output the report
	foreach my $assetName (sort keys %{$reportHash}) {
		print "$assetName";
		foreach my $dataName (split(/,/, $dataList)) {
			if (defined $reportHash->{$assetName}->{$dataName}) {
				print "\t" . $reportHash->{$assetName}->{$dataName};
			} else {
				print "\t__UNDEF__";
			}
		}
		print "\n";
	}
}

