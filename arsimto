#!/usr/bin/perl
# vim: set noexpandtab:
# --
# A recent battle with vim and a Go program finally settled this for me.
# Tabs for indent, spaces for formatting. If you change your shiftwidth and
# tabstop to different values and your code looks ugly, say aloud: tabs
# for indent, spaces for formatting.
# --
# arsimto is a radically-simple inventory management tool.
# license: gpl v2.
# author: Tim Ellis, CTO Fifth Sigma, Inc.

use strict;
use warnings;

# things passed in via arguments
my @extraArgs;
my $mode = 0;
my $verbose = 0;
my $assetList = '';
my $dataList = '';
my $collectServer = 0;
my $longMode = 0;

# colour-based variables
my $colourisedOutput = 0;
my $colourPalette = '0,36,32,35,34';
my $regularColour = "";
my $poolColour = "";
my $assetColour = "";
my $dataColour = "";
my $summaryColour = "";

# names of directories
my $poolDir = "Pools";
my $assetDir = "Assets";

# list of posible command sections
my $cmdList = "add, ln, ls, mv, rename, rm, help";

# a constant meaning an entry is at the top of a tree
my $topLevel = '__TOP_LEVEL_NO_PARENT';
my $vennMode = 'union';
my $pristineMode = 0;

# no arguments passed in? short help.
unless (scalar @ARGV) {
	doArgs('short');
	exit 255;
}

# if they want an rcfile, must be first arg
my $rcFile = $ENV{"HOME"} . "/.arsimtorc";
if ($ARGV && $ARGV[0] =~ /^-+r(cfile)*=(.+)$/) { $rcFile = $2; }

# read in rcfile if it exists - it'll just be args
if (open (IFILE, "< $rcFile")) {
	my $inLine;
	while ($inLine = <IFILE>) {
		chomp ($inLine);
		# must put args from rcfile at start so options passed on the
		# commandline will override them
		if ($inLine =~ /^-+(\w+)/) {
			unshift (@ARGV, $inLine);
		}
	}
}

# parse input arguments. put anything unparsed onto @extraArgs
foreach my $arg (@ARGV) {
	if ($arg =~ /^-+h(elp)*$/)                  { doArgs('long'); exit 0; }
	elsif ($arg =~ /^-+a(ssets)*=(.+)$/)        { $assetList = $2; }
	elsif ($arg =~ /^-+c(ollect)*=(.+)$/)       { $collectServer = $2; }
	elsif ($arg =~ /^-+c(olor)*$/)              { $colourisedOutput = 1; }
	elsif ($arg =~ /^-+p(alette)*=(.+)$/)       { $colourPalette = $2; $colourisedOutput = 1; }
	elsif ($arg =~ /^-+d(ata)*=(.+)$/)          { $dataList = $2; }
	elsif ($arg =~ /^-+i(nt)*/)                 { $vennMode = 'intersection'; }
	elsif ($arg =~ /^-+l(ong)*/)                { $longMode = 1; }
	elsif ($arg =~ /^-+p(rist)*/)               { $pristineMode = 'pristine'; }
	elsif ($arg =~ /^-+v(erbose)*$/)            { $verbose = 1; }
	elsif ($cmdList =~ /\b$arg\b/)              { $mode = $arg; }
	else { push (@extraArgs, $arg); }
}

# if they don't know what they're doing but tried something, help them
unless ($mode) {
	print STDERR "Commands: $cmdList. Use -h for long help or no arguments for short help.\n";
	exit 255;
}

# variables to support colourised output
if ($colourisedOutput) {
	# input should be comma-separated list of numerals
	my @cp = split (',', $colourPalette);
	# add ANSI colour commands around the values - final looks like ^[[32m
	for (my $i=0; $i < scalar @cp; $i++) {
		$cp[$i] = chr(27) . '[' . $cp[$i] . 'm';
	}
	($regularColour, $poolColour, $assetColour, $dataColour, $summaryColour) = @cp;
}

# regardless of anything previous, if they're not on a terminal, don't
# output colour codes
unless (-t STDOUT) { $colourisedOutput = 0; }

# determine the mode they're requesting and do the needful
if ($mode eq 'add') {
	addAssets();
} elsif ($mode eq 'ln') {
	lnAssets();
} elsif ($mode eq 'ls') {
	listAssets();
} elsif ($mode eq 'mv') {
	mvAssets();
} elsif ($mode eq 'rm') {
	rmAssets();
} elsif ($mode eq 'rename') {
	renameAssets();
} elsif ($mode eq 'help') {
	doArgs ('short');
}
exit 0;

# ----------------------------------------------------------------------------------------
# subroutines follow
# ----------------------------------------------------------------------------------------

# give help. either short and concise or long and verbose including a tutorial.
sub doArgs {
	my $helpLength = shift;

	print "usage: $0 <command> [<assetObj>|<poolObj>] [<assetObj>|<poolObj>...]\n";
	print "  [-v|--verboase] [-h|--help] [-d=...|--data=<dataList>] [-p|--pristine]\n";
	print "  [-c|--color] [-l|--long] [-p=...|--palette=<p1,p2,p3,p4,p5>]\n";
	print "  [-r=...|--rcfile=<rcFile>]\n";
	print "\n";
	print "  -h        Long version help. Run without arguments for short help.\n";
	print "  -l        Or --long. Long output for Pools/ listing.\n";
	print "  -p        Or --pristine. Don't reformat data values to be more (human-)readable.\n";
	print "  -c        Or --color, output in colorized mode.\n";
	print "  -p=...    Or --palette=..., the colors to output. ANSI color codes. Default is $colourPalette.\n";
	print "  -v        Verbose/debugging output\n";
	print "  <command> is one of $cmdList.\n";
	print "\n";
	print "add :: \n";
	print "  $0 add <assetName> [<assetName>...]\n";
	print "    --data=n1:v1[,n2:v2,...,nN:vN] [--collect=<hostName>]\n";
	print "  Add asset into inventory. Data attributes are added to all assets listed.\n";
	print "  --collect=<hostName> SSHes to hostName to get basic data from the host.\n";
	if ($helpLength eq 'long') {
		print "Examples:\n";
		print "  $0 add dc01   --data=capacity:5000\n";
		print "  $0 add rack01   --data=U:48\n";
		print "  $0 add switch01 --data=ports:48\n";
		print "  $0 add server{10..25} --data=ram:16GB,disk:2048GB,nic:10Gb\n";
		print "  for i in {10..25} ; do $0 add server\$i --data=ip:192.168.1.1\$i ; done\n";
	}
	print "\n";
	print "ln :: \n";
	print "  $0 ln <Pool> <groupedObject> [<groupedObject>...]\n";
	print "  Logically pools Assets or Pools to each other. If <Pool> doesn't already exist,\n";
	print "  it is created.\n";
	if ($helpLength eq 'long') {
		print "Examples:\n";
		print "  $0 ln dc01 rack01\n";
		print "  $0 ln rack01 switch01 server{10..25}\n";
		print "  $0 ln switch01 server{10..25}\n";
		print "  $0 ln www server{10..20}\n";
		print "  $0 ln db server{21..25}\n";
		print "  $0 ln production server{18..23}\n";
	}
	print "\n";
	print "ls :: \n";
	print "  $0 ls <object> --data=n1[,n2...] [--intersection|-i]\n";
	print "  If you pass in the $poolDir/ then you get a view of all Pools. If you pass in the\n";
	print "  name(s) of Pool, you get all objects in that Pool or group of Pools. If you further\n";
	print "  pass --intersection (or -i) then you get only objects that are in all the Pools.\n";
	print "  If you pass --data=... then you get all data about each object returned.\n";
	if ($helpLength eq 'long') {
		print "Examples:\n";
		print "  $0 ls Assets\n";
		print "  $0 ls Pools/db\n";
		print "  $0 ls Pools/db/server02\n";
		print "  $0 ls Pools/db  Pools/www  Pools/dc01\n";
		print "  $0 ls production db --intersection\n";
		print "  $0 ls --data=ram,ip Pools/db\n";
		print "  $0 ls --data=ip,nic Pools/www\n";
	}
	print "\n";
	print "mv ::\n";
	print "  $0 mv <assetToMove> [<assetToMove>...] <destPool>\n";
	print "  Moves asset from one pool to another. Final argument is the destination pool for all\n";
	print "  arguments that precede it.\n";
	if ($helpLength eq 'long') {
		print "Examples:\n";
		print "  $0 mv Pools/db/server02 Pools/www\n";
	}
	print "\n";
	print "rm :: \n";
	print "  $0 rm <firstAsset> [secondAsset...]\n";
	print "  Remove an asset from the system and all pools it's in.\n";
	if ($helpLength eq 'long') {
		print "Examples:\n";
		print "  $0 rm server13\n";
	}
}

# add assets to the database
sub addAssets {
	my $actionTaken = "Added new";

	foreach my $asset (@extraArgs) {
		# make the dir for the asset to store its data
		if (-d "$assetDir/$asset") {
			$actionTaken = "Modified existing";
		} else {
			system ("mkdir -p $assetDir/$asset");
		}

		# put in each data key:value pair
		foreach my $data (split(/,/, $dataList)) {
			my ($key, $val);
			if ($data =~ /^(.+?):(.+)$/) {
				$key = $1;
				$val = $2;
			}
			if ($verbose) { print STDERR " - Adding $key for $asset\n"; }

			# search for existing keys and replace them
			my $existingKeys = `find -L $assetDir/$asset/$key* 2>/dev/null`;
			if ($existingKeys) {
				if ($verbose) { print STDERR " - Removing old keys $key for $asset\n"; }
				system ("rm -f $assetDir/$asset/$key*");
			}

			# create the new key
			system ("touch $assetDir/$asset/$data");
		}

		print " - $actionTaken Asset $asset\n";

		# TODO: use facter or something real
		# if they want us to collect some info automagically...
		if ($collectServer) {
			print " - Collecting information about $asset via SSH from $collectServer...\n";
			if ($verbose) { print STDERR "   - Collecting intIP\n"; }

			my $ifConfig = `ssh $collectServer "ifconfig | egrep 'addr:10|addr:192.168'"`;
			my $intIP = 0;
			if ($ifConfig =~ /addr:(.+?)\s+/) {
				$intIP = $1;
			}

			if ($verbose) { print STDERR "   - Collecting extIP\n"; }
			my $extIP=`ping -c 1 $collectServer | grep 'bytes of data' | awk -F '(' '{print \$2}' | awk -F ')' '{print \$1}'`;
			chomp ($extIP);

			if ($verbose) { print STDERR "   - Collecting CPUcount\n"; }
			my $cpuCount = `ssh $collectServer "cat /proc/cpuinfo | grep ^processor | wc -l"`;
			chomp ($cpuCount);

			if ($verbose) { print STDERR "   - Collecting Memory\n"; }
			my $memory = 0;
			my $memUnits = "?";
			my $memInfo = `ssh $collectServer "cat /proc/meminfo | grep ^MemTotal"`;
			if ($memInfo =~ /(\d+)\s+(\w+)$/) {
				$memory = $1;
				$memUnits = $2;
			}

			# if we collected a piece of data, put it into the asset
			if ($extIP)    { system ("touch $assetDir/$asset/ip:$extIP"); }
			if ($intIP)    { system ("touch $assetDir/$asset/intip:$intIP"); }
			if ($cpuCount) { system ("touch $assetDir/$asset/cpus:$cpuCount"); }
			if ($memory)   { system ("touch $assetDir/$asset/mem$memUnits:$memory"); }
		}
	}
}

sub rmAssets {
	foreach my $asset (@extraArgs) {
		# we need only the asset name, no path info
		if ($asset =~ /\/(.+)$/) {
			$asset = $1;
		}
		if ($verbose) { print STDERR " + Removing $asset from Assets $assetDir...\n"; }
		system ("find $assetDir -name '$asset' -exec rm -rf {} \\; 2>/dev/null");
		if ($verbose) { print STDERR " + Removing $asset from Pools $poolDir...\n"; }
		system ("find $poolDir -name '$asset' -exec rm -rf {} \\; 2>/dev/null");
		print " - Removed $asset from system.\n";
	}
}

# move an asset from one pool to another
sub mvAssets {
	my $numMvArgs = scalar @extraArgs;
	my $destPool = $extraArgs[$numMvArgs - 1];
	$destPool =~ s/\/$//g;

	foreach my $assetToMove (@extraArgs) {
		# these are symlinks we're moving around, if there's a trailing slash,
		# then GNU mv will hate on us
		$assetToMove =~ s/\/$//g;

		if (-d $assetToMove && -d $destPool && $assetToMove ne $destPool) {
			system ("mv $assetToMove $destPool");
			print " - Moved Asset $assetToMove --> $destPool\n";
		}
	}
}

# simply connect assets to each other
sub lnAssets {
	if (scalar @extraArgs > 1) {
		my $parentAsset = shift (@extraArgs);

		# if they prefixed the parentAsset with Pools/, remove that bit
		if ($parentAsset =~ /^(.*$poolDir\/)(.+)$/) {
			$parentAsset = $2;
		}

		# all these are linkees
		foreach my $childAsset (@extraArgs) {
			# every pool should also be an asset so it can have data
			system ("mkdir -p $poolDir/$parentAsset && mkdir -p $assetDir/$childAsset");

			# by default the linkee is an asset...
			system ("cd $poolDir/$parentAsset && ln -sf ../../$assetDir/$childAsset ./");

			# ...if there's a Pool, make the linkee the Pool instead - Pools
			# are essentially indexes of links
			system ("if [ -d ../$childAsset ] ; then ln -sf ../$childAsset ./ ; fi");
			print " - Connected $parentAsset --> $childAsset\n";
		}
	} else {
		print STDERR " E Error: You must provide a list of assets to connect.\n";
	}
}

# simple list of what assets are in what - also applies to pools
# if a given Pools/X contains an asset Y, and Pools/Y exists,
# then Pools/Y is a child of Pools/X
sub listAssets {
	my $reportHash;

	# no args at all? just list pools.
	if (!defined $extraArgs[0]) {
		$extraArgs[0] = $poolDir;
	}

	# two major modes: first is output a view of all the pools.
	if ($extraArgs[0] =~ /^$poolDir\/*$/) {
		# first collect all top-level pool names, some of which might
		# be children of others
		my @poolList = split(/\n/, `ls -1 $poolDir`);

		# put the list of top-level pools into the report hash...
		foreach my $currPool (@poolList) {
			$reportHash->{$currPool}->{'parent'} = $topLevel;
		}

		# second collect all assets inside the top-level pool names
		# and if they match top-level pool, create two-way link between
		# them in the hash
		foreach my $currPool (@poolList) {
			my $assetCount = 0;
			my @assetList = split(/\n/, `ls -1 $poolDir/$currPool`);

			foreach my $oneAsset (@assetList) {
				if (defined $reportHash->{$oneAsset}) {
					if ($verbose) { print STDERR "   - Setting $currPool --> $oneAsset link\n"; }
					if ($longMode) {
						$reportHash->{$currPool}->{'children'} .= "($oneAsset) ";
					} else {
						$reportHash->{$currPool}->{'children'} .= "()";
					}
				} else {
					$assetCount++;
				}
			}
			if ($assetCount) {
				if ($colourisedOutput) {
					$reportHash->{$currPool}->{'children'} .= $assetColour;
				}
				$reportHash->{$currPool}->{'children'} .= "+" x $assetCount;
				if ($colourisedOutput) {
					$reportHash->{$currPool}->{'children'} .= $regularColour;
				}
			}
		}

		# third, output the hash
		outputHashTree ($reportHash, $topLevel, 0);

		return 0;
	}

	# second major mode is outputing a list of Assets - outsource this to
	# reportAssets()
	reportAssets();
}

# based on the objects listed in @extraArgs, make an array of assets in the
# pools that list represents
sub collectAssetList {
	my $assetList;
	my $assetHash;
	my $runNum = 0;

	foreach my $listDest (@extraArgs) {
		if ($verbose) { print STDERR " - Traversing $listDest\n"; }

		my @assetsFound;
		if (-e $listDest) {
			# if they pass an actual dir that exists
			@assetsFound = split(/\n/, `ls -1 $listDest`);
		} elsif (-e "$poolDir/$listDest") {
			# maybe they passed a pool name sans dir prefix?
			@assetsFound = split(/\n/, `ls -1 $poolDir/$listDest`);
		} elsif (-e "$assetDir/$listDest") {
			# oh maybe they passed an asset name sans dir prefix? hope!
			@assetsFound = split(/\n/, `ls -1 $assetDir/$listDest`);
		}

		# here we decide if we're doing the intersection of the various pools
		if ($vennMode eq 'intersection') {
			my @interSection;

			# initial run, fill asset list, otherwise, do intersection
			foreach my $foundAsset (@assetsFound) {
				if ($runNum > 0) {
					# time to do intersection!
					if (defined $assetHash->{$foundAsset}) {
						push (@interSection, $foundAsset);
					}
				} else {
					# fill initial asset list
					push (@interSection, $foundAsset);
				}
			}

			if ($verbose) { print STDERR " - Adding " . scalar @interSection . " items in this round.\n"; }
			$assetHash = undef;
			foreach my $foundAsset (@interSection) {
				$assetHash->{$foundAsset} = 1;
			}
		} else {
			# do they want all assets or just an intersection from the pools?
			foreach my $foundAsset (@assetsFound) {
				if ($verbose) { print STDERR " - Adding $foundAsset from $listDest\n"; }
				$assetHash->{$foundAsset} = 1;
			}
		}

		$runNum++;
	}

	@{$assetList} = sort keys %{$assetHash};
	return $assetList;
}

# traverse a tree struct implemented inside a hash
sub outputHashTree {
	my $hashToTraverse = shift;
	my $rootLevel = shift;
	my $indent = shift;
	my $reportRows = 0;

	foreach my $parentKey (sort keys %{$hashToTraverse}) {
		if ($hashToTraverse->{$parentKey}->{'parent'} eq $rootLevel) {
			print "($parentKey)";
			$reportRows++;
			if (defined $hashToTraverse->{$parentKey}->{'children'}) {
				$hashToTraverse->{$parentKey}->{'children'} =~ s/,$//;
				print " --> ";
				if ($colourisedOutput) { print $poolColour; }
				print $hashToTraverse->{$parentKey}->{'children'};
				if ($colourisedOutput) { print $regularColour; }
			}
			print "\n";
		}
	}
	# if they're in a terminal, tell them how many matching Pools. if they're piping
	# then skip that. it'll just confuse things.
	if (-t STDOUT) {
		if ($colourisedOutput) { print STDERR $summaryColour; }
		print STDERR " - $reportRows pools.\n";
		if ($colourisedOutput) { print STDERR $regularColour; }
	}
}

# collect the data for every asset specified then dump it out
sub reportAssets {
	my $objectList = '';
	my $reportHash;
	my $outputCol = 0;

	$assetList = collectAssetList();

	# this is a list of actual Assets, which might also be Pools - so collect
	# Data attributes for each asset first
	foreach my $foundAsset (@{$assetList}) {
		$objectList = `find -L $assetDir/$foundAsset -type f -name '*:*' 2>/dev/null`;

		if ($objectList) {
			if ($verbose) { print STDERR " - Found attributes for $foundAsset - adding them...\n"; }
			# next, grab out the data we want and put into a hash of assets
			foreach my $oneLine (split(/\n/, $objectList)) {
				if ($oneLine =~ /$foundAsset\/(.+?):(.+)$/) {
					my $dataName = $1;
					my $dataVal = $2;

					# if this data matches the list they want, put into report
					if ($dataList eq '*' || $dataList =~ /\b$dataName\b/) {
						if (!$pristineMode && $dataVal =~ /^(\d+)$/) {
							$dataVal = addCommas($dataVal);
						}
						$reportHash->{$foundAsset}->{$dataName} = $dataVal;
					} else {
						$reportHash->{$foundAsset}->{$dataName} = "__O_GOD_UNFOUND__";
					}
				}
			}
		} else {
			if ($verbose) { print STDERR " - No attributes for $foundAsset - adding with none.\n"; }
			# the asset was in the Pool, but had no attributes, but we still want to
			# see the object in the list
			$reportHash->{$foundAsset}->{nil} = 1;
		}
	}

	# if they specify nothing, show them Asset names
	unless ($dataList) { $dataList = 'name'; }

	# we now have all assets and their Data attributes - output the report
	my $reportRows = 0;
	foreach my $assetName (sort keys %{$reportHash}) {
		# if it's an Asset/, print it as asset color and if long output with a
		# preceding +. If it's a Pool/, print it pool color with a () preceding.
		if (-e "$poolDir/$assetName" && $dataList =~ /\bname\b/) {
			if ($colourisedOutput) { print $poolColour; }
			if ($longMode) { print "() "; }
			print "$assetName";
			if ($colourisedOutput) { print $regularColour; }
			$outputCol++;
		} elsif ($dataList =~ /\bname\b/) {
			if ($colourisedOutput) { print $assetColour; }
			if ($longMode) { print " + "; }
			print "$assetName";
			if ($colourisedOutput) { print $regularColour; }
			$outputCol++;
		}

		# output the data they requested
		foreach my $dataName (split(/,/, $dataList)) {
			next if ($dataName eq 'name');

			# random stuff to print depending on situation
			if ($verbose) { print STDERR " - Outputting $dataName\n"; }
			if ($colourisedOutput) { print $dataColour; }
			if ($outputCol) { print "\t"; }

			if ($dataName eq '*') {
				foreach my $key (keys %{$reportHash->{$assetName}}) {
					print $reportHash->{$assetName}->{$key};
				}
			} elsif ($dataName =~ /^"(.+?)"$/) {
				print "$1";
			} elsif (defined $reportHash->{$assetName}->{$dataName}) {
				print $reportHash->{$assetName}->{$dataName};
			} else {
				print "__UNDEF__";
			}
			$outputCol++;

			# put terminal back into normal mode
			if ($colourisedOutput) { print $regularColour; }
		}

		# newline! :)
		print "\n";
		$reportRows++;
		$outputCol = 0;
	}
	# if they're in a terminal, tell them how many matching assets. if they're piping
	# then skip that. it'll just confuse things.
	if (-t STDOUT) {
		if ($colourisedOutput) { print STDERR $summaryColour; }
		print STDERR " - $reportRows matching assets.\n";
		if ($colourisedOutput) { print STDERR $regularColour; }
	}
}

sub renameAssets {
	my $assetToRename = shift (@extraArgs);
	my $assetNewName = shift (@extraArgs);

	# sanity check their input
	if ($assetToRename =~ /\//) {
		print STDERR " E You should only give the bare asset name without any pool prefixes.\n";
		return 255;
	}

	if ($verbose) { print STDERR " - Locating all Pool objects linking to $assetDir/$assetToRename\n"; }
	my $fileSystemNamesToRename = `find -L $poolDir -samefile $assetDir/$assetToRename`;

	# first rename the asset itself
	if (-e "$assetDir/$assetNewName") {
		print STDERR " - Cowardly refusing to overwrite $assetDir/$assetNewName.\n";
		print STDERR " - Aborting procedure! Remove Asset $assetNewName from system\n";
		print STDERR "   before renaming something to it.\n";
		return 251;
	} else {
		if ($verbose) { print STDERR " - Moving $assetDir/$assetToRename --> $assetDir/$assetNewName\n"; }
		system ("mv $assetDir/$assetToRename $assetDir/$assetNewName");
	}

	$fileSystemNamesToRename =~ s/\/$assetToRename//gs;
	my @assetLocations = split (/\n/, $fileSystemNamesToRename);

	foreach my $linkLoc (@assetLocations) {
		# because of pools-in-pools it can happen that a previous
		# re-ln already did this. so just don't do the work twice
		# but don't abort the procedure.
		unless (-e "$linkLoc/$assetNewName") {
			if ($verbose) { print STDERR " - Linking $assetDir/$assetNewName into $linkLoc and removing $assetToRename\n"; }
			system ("cd $linkLoc && ln -s ../../$assetDir/$assetNewName ./ && rm $assetToRename");
		}
	}

	print " - Renamed $assetToRename --> $assetNewName\n";
}

# make a number filled with commas - humans hate to see a number like
# 57106739592. It's really confusing.
sub addCommas {
	my $theNumber = shift;
	$theNumber = reverse $theNumber;
	$theNumber =~ s<(\d\d\d)(?=\d)(?!\d*\.)><$1,>g;
	return reverse $theNumber;
}

